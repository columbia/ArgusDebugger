#include "loader.hpp"
#include <unistd.h>
#include <fcntl.h>
namespace LoadData
{
    meta_data_t meta_data = {
                .tpc_maps_file = "./input/tpcmap.log", /*generated by trace tool*/
                .libs_dir = "./input/libs", /*generated by trace tool*/
                .libinfo_file = "./input/libinfo.log", /*generated by loader*/
                .suspicious_api = "ConnectionSetSpinning",
                .symbolicate_procs_file = "./input/required_libs", /*optional*/
                .procs_file = "./input/current_procs.log", /*optional for load_all()*/
                .host = "Undefined",
                .pid = 0,
                .nthreads = 4
   };

    std::map<tid_t, ProcessInfo *> tpc_maps;
    std::map<int, std::string> mig_dictionary;
    std::map<std::string, uint64_t> bsc_name_index_map;
    std::map<std::string, uint64_t> msc_name_index_map;
    std::map<std::string, int> symbolic_procs;
    
	std::string find_comm_in_procs(pid_t target_pid);
    void load_tpc_maps(const std::string log_file, std::map<tid_t, ProcessInfo*> &tpc_maps)
    {
        std::ifstream infile(log_file);
        if (infile.fail())
            return;

        tid_t tid;
        pid_t pid;
        std::string command, line;
    
        while (getline(infile, line)) {
            std::istringstream iss(line);
            if (!(iss >> std::hex >> tid >> pid)
                || !getline(iss >> std::ws, command)
                || !command.size())
				continue; 
			assert(command != "");
            if (tpc_maps.find(tid) != tpc_maps.end())
                tpc_maps[tid]->update_process_info(tid, pid, command);
            else
                tpc_maps[tid] = new ProcessInfo(tid, pid, command);       
        }
        
        for (auto element: LoadData::tpc_maps) {
            assert(element.second != nullptr);
        }

        infile.close();
    }
    
    std::string pid2comm(pid_t pid)
    {
        std::string proc_comm = "";
        std::map<uint64_t, ProcessInfo *>::iterator it;
        for (it = LoadData::tpc_maps.begin(); it !=  LoadData::tpc_maps.end(); it++) {
            assert(it->second);
            if ((it->second)->get_pid() == pid) {
				proc_comm = (it->second)->get_procname();
				break;
            }
        }
		if (proc_comm == "")
			proc_comm = find_comm_in_procs(pid);
		if (proc_comm == "")
        	LOG_S(INFO) << "No comm name found for pid " << std::hex << pid;
        return proc_comm;
    }

	pid_t tid2pid(tid_t tid)
	{
		if (tpc_maps.find(tid) == tpc_maps.end())
			return -1;
		return tpc_maps[tid]->get_pid();
	}

    void load_mig_dictionary(const struct mig_service table[], uint32_t size,std::map<int, std::string> &mig_dictionary)
    {
        for (int i = 0; i < size; i++) {
            std::string name(table[i].mig_name);
            mig_dictionary[table[i].mig_num] = name;
        }
    }
    
    void build_syscall_name_index_map(const struct syscall_entry table[], uint32_t size,std::map<std::string, uint64_t> &sysmap)
    {
        sysmap.clear();
        for (int i = 0; i < size; i++) {
            std::string name(table[i].syscall_name);
            if (name.length() > 24) 
                name = name.substr(0, 24);
            sysmap[name] = i;
        }
    }
    
        
//#define HASHVAL 17
    //static inline uint64_t hash_tid(uint64_t tid, std::string unused) { return tid % HASHVAL + 1;}

    uint64_t map_op_code(uint64_t unused, std::string opname)
    {
        uint64_t code = 0;
        if (opname.find("BSC_") != std::string::npos)
            code = LoadData::op_code_map.at("BSD_SYSCALL");
        else if (opname.find("MSC_") != std::string::npos)
            code = LoadData::op_code_map.at("MACH_SYSCALL");
        else if (LoadData::op_code_map.find(opname) != op_code_map.end())
            code = LoadData::op_code_map.at(opname);
        return code;
    }
	
	std::string find_comm_in_procs(pid_t target_pid)
	{
        std::ifstream infile(meta_data.procs_file);    
        if (infile.fail()) {
            std::cerr << "Error: fail to open file " << meta_data.procs_file << std::endl;
			return "";
		}

        std::string line, procname;
        pid_t pid = 0;
        while (getline(infile, line)) {
            std::istringstream iss(line);
            if (!(iss >> pid))
                goto out;
            if (!getline(iss >> std::ws, procname) || !procname.size())
                goto out;

			if (pid == target_pid) {
				if (pid == 684) {
					LOG_S(INFO) << "684 proc " << procname;
				}
				return procname;
			}
        }
    out:
        infile.close();
        std::cerr << "Fail to read pid 0x" << std::hex << target_pid << " from " << meta_data.procs_file << std::endl;
		return "";
    }


    bool find_proc_in_procs(std::string proc_name)
    {
        std::ifstream infile(meta_data.procs_file);    
        if (infile.fail()) {
            std::cerr << "Error: fail to open file " << meta_data.procs_file << std::endl;
            exit(EXIT_FAILURE);
        }
        std::string line, procname;
        pid_t pid = 0;
        while (getline(infile, line)) {
            std::istringstream iss(line);
            if (!(iss >> pid))
                goto out;
            if (!getline(iss >> std::ws, procname) || !procname.size())
                goto out;
            if (procname == proc_name) {
                infile.close();
                return true;
            }
        }
    out:
        infile.close();
        std::cerr << "Fail to read procname " << proc_name << " from " << meta_data.procs_file << std::endl;
        return false;
    }

#include <dirent.h>
    bool load_lib(std::string proc_name, std::string lib_info_file) 
    {
        if (!meta_data.libs_dir.size())
            return false;
        DIR *dir;
        struct dirent *entry;
        dir = opendir(meta_data.libs_dir.c_str());

        if (!dir) {
            std::cerr << "Error: missing libraries info directory" << std::endl;
            return false;
        }

        std::ofstream outfile(lib_info_file, std::ios::out | std::ios::app);
        bool found = false;
        while ((entry = readdir(dir))) {
            if (!entry) {
                std::cerr << "Error: fail to read file name from entry " << std::endl;
                goto out;
            }

            if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, ".."))
                continue;
            std::string filename(meta_data.libs_dir + "/" + entry->d_name);
            std::ifstream infile(filename);
            if (infile.fail()) {
                std::cerr << "Error: fail to open file " << entry->d_name << std::endl;
                goto out;
            }

            {
                std::string line;
                if (!getline(infile, line)) {
                    infile.close();
                    std::cerr << "Error: read from file " << filename << " fail 0" << std::endl;
                    goto out;
                }

                std::istringstream iss(line);
                std::string procname, arch, unused;
                pid_t pid;
                if (!(iss >> unused >> std::hex >> pid >> arch) || !(getline(iss >> std::ws, procname)) || !procname.size()) {
                    infile.close();
                    std::cerr << "Error: parse line from file " << filename << " fail 1" << std::endl;
                    std::cerr << "\t" << line << std::endl;
                    goto out;
                }

                if (procname == proc_name) {
                    found = true;
                    infile.seekg(0);
                    outfile << infile.rdbuf();
                    infile.close();
                }
            }
        }
        outfile.close();
        closedir(dir);
        if (!found)
            return false;
        return true;
        
    out:
        closedir(dir);
        std::cerr << "Error: missing memory layout info for proc " << proc_name << std::endl;
        return false;
    }
    
    bool load_all_libs(std::string lib_info_file)
    {
        if (!meta_data.libs_dir.size() || !meta_data.procs_file.size())
            return false;
        std::ifstream infile(meta_data.procs_file);    
        if (infile.fail()) {
            std::cerr << "Error: fail to open file " << meta_data.procs_file << std::endl;
            return false;
        }
        std::string line, procname;
        pid_t pid;
        while (getline(infile, line)) {
            std::istringstream iss(line);
            if (!(iss >> pid) || !getline(iss >> std::ws, procname) || !procname.size())
                goto out;

            if (!load_lib(procname, lib_info_file)) {
                std::cerr << "Error: fail to load lib for proc " << procname  << " [" << pid << "]" << std::endl;
                continue;
            }
        }
    out:
        infile.close();
        return false;
    }

    void init_lib_info(std::string lib_info_file)
    {
        /* regnerate lib info */
        if (meta_data.libs_dir.size() && access(meta_data.libs_dir.c_str(), R_OK) == 0) {
            if (access(lib_info_file.c_str(), R_OK) != 0)
                std::cerr << lib_info_file << " does not exist" << std::endl;
            else if (remove(lib_info_file.c_str()))
                std::cerr << "Fail to delete " << lib_info_file << std::endl;
            else
                std::cerr << "Delete " << lib_info_file << " successfully"<< std::endl;
        } else {
            std::cerr << "No lib information exists" << std::endl;
            return;
        }

        bool load_success = true;
        std::map<std::string, int> visit_map; 
        visit_map.clear();

        if (access(meta_data.symbolicate_procs_file.c_str(), R_OK) == 0) {
            std::ifstream input(meta_data.symbolicate_procs_file, std::ifstream::in);
            if (!input.is_open()) {
                load_success = false;
                std::cerr << "Fail to open file " << meta_data.symbolicate_procs_file << std::endl;
            }

            if (!input.good()) {
                input.close();
                load_success = false;
                std::cerr << meta_data.symbolicate_procs_file << " file broken" << std::endl;
            }

            std::string proc_name;

            while(getline(input, proc_name)) {
                LOG_S(INFO) << "Load lib for " << proc_name;

                if (visit_map.find(proc_name) != visit_map.end())
                    continue;

                visit_map[proc_name] = 1;
                if (!load_lib(proc_name, lib_info_file)) {
                    load_success = false;
                    std::cerr << "Fail to load lib for " << proc_name << std::endl;
                }
            }
            input.close();
        }
        
        if (symbolic_procs.size() > 0) {
            load_success = true;
            std::map<std::string, int>::iterator it;
            for (it = symbolic_procs.begin(); it != symbolic_procs.end(); it++) {
                std::string proc_name = it->first;
                if (visit_map.find(proc_name) != visit_map.end())
                    continue;

                visit_map[proc_name] = 1;
                if (!load_lib(proc_name, lib_info_file)) {
                    load_success = false;
                    std::cerr << "Fail to load lib for [user input process] " << proc_name << std::endl;
                }
            }
        }
        visit_map.clear();
    }

    void preload()
    {
        load_tpc_maps(meta_data.tpc_maps_file, tpc_maps);
        init_lib_info(meta_data.libinfo_file);
        load_mig_dictionary(mig_table, mig_size, mig_dictionary);
        build_syscall_name_index_map(bsd_syscall_table, bsc_size, bsc_name_index_map);
        build_syscall_name_index_map(mach_syscall_table, msc_size, msc_name_index_map);
    }
}
